//师兄or师姐，你看完代码能给个评价吗，求勾搭，qq:1319140579 静候佳音
//方法二的代码，已调试成功
#include <iostream>  
#include <vector>  
#include <algorithm>  
using namespace std;

typedef struct node
{
	int data;     //时间值  
	int flag;    //1表示开始时间，0表示结束时间  
}Node;

bool compare(Node n1, Node n2)
{
	return n1.data<n2.data;    //排列  
}

int maxrepeat(vector<Node> v)   //最大重叠数  
{
	int curr = 0, sum = 0;
	vector<Node>::iterator it = v.begin();
	for (; it <= v.end(); it++)
	{
		if ((*it).flag)
		{
			curr++;
			if (curr>sum)
				sum = curr;
		}
		else
			curr--;

	}
	return sum;
}

void main()
{
	int i, n;
	vector<Node> v;
	cin >> n;
	Node t;
	for (i = 1; i <= 2 * n; i++)
	{
		cin >> t.data;
		t.flag = i % 2;
		v.push_back(t);
	}

	sort(v.begin(), v.end(), compare);
	cout << maxrepeat(v) << endl;
}

//下面是方法一的代码，还有点问题，师姐要是有兴趣可以看一看啊，不过写得这么烂应该不会有兴趣看吧……
*/#include <iostream> 
using namespace std;
void QuickSort(int a[], int b[],int p, int r);
int Partition(int a[], int b[],int p, int r);
void Swap(int &i, int &j);
int Greed(int a[], int b[], int n);

int main()
{
	int i;
	int n;
	cin >> n;
	int a[100], b[100];   //a[n]是结束时间，b[n]为开始时间
	for (i = 0; i < n; i++)
		cin >> b[i] >> a[i];
	QuickSort(a, b, 0, n - 1);
	cout<<Greed(a, b, n)<<endl;
	return 0;
}

int Greed(int a[], int b[], int n)
{
	int x = 0,i;
	int c[100] = {0};
	for (i = 0; i < n; i++)
		c[i] = i;
	while (n!=0)
	{
		int j = 0;
		int y = c[0];
		int oldj = n;
		for (i = c[1]; i < n; i++)
		{
			j = 0;
			if (a[c[i]]>b[y])
			{
				c[j] = c[i];       //	这附近的逻辑一直有问题，不知道怎么才能简化掉
				j++; 
			}
			
			else
			{
				n--;
				y = c[i];
			}

			if (j == oldj)         //我也不想写这么多的if语句，只是因为一开始算法没设计好
			{                      //所以调试的时候加了许多控制语句
				n -= j;
				x += j;
				return x;
			}
		}
		oldj = j;
		x++;
	}
	return x;
}

void QuickSort(int a[],int b[], int p, int r)
{
	if (p<r)
	{
		int q = Partition(a,b, p, r);
		QuickSort(a, b, p, q - 1);
		QuickSort(a,b, q + 1, r);
	}
}


int Partition(int a[],int b[], int p, int r)
{
	int x = a[r];
	int i = p - 1;
	for (int j = p; j<r; j++)
	{
		if (a[j]<x)
		{
			i++;
			Swap(a[i], a[j]);
			Swap(b[i], b[j]);
		}
	}
	Swap(a[++i], a[r]);
	Swap(b[i], b[r]);
	
	return i;
}

void Swap(int &i, int &j)
{
	int temp = i;
	i = j;
	j = temp;
}
*/
